<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>井字遊戲 - 教學版</title>
    
    <!-- CSS (樣式表) 開始 -->
    <!-- 所有的樣式都寫在這裡 -->
    <style>
        /* 基礎設定：讓遊戲置中，並設定字體 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex; /* 使用 Flexbox 佈局 */
            flex-direction: column; /* 讓子元素垂直排列 */
            align-items: center; /* 水平置中 */
            justify-content: center; /* 垂直置中 */
            min-height: 100vh; /* 最小高度為整個視窗 */
            background-color: #f0f2f5; /* 淺灰色背景 */
            color: #333;
        }

        h1 {
            font-size: 2.5rem;
            color: #1a1a1a;
        }

        /* 遊戲狀態顯示區域 */
        #status {
            font-size: 1.5rem;
            margin: 20px 0; /* 上下邊距 20px，左右 0 */
            font-weight: bold;
        }

        /* 遊戲棋盤：使用 CSS Grid 快速建立 3x3 格子 */
        #game-board {
            display: grid;
            /* 定義三行，每行 100px */
            grid-template-columns: repeat(3, 100px);
            /* 定義三列，每列 100px */
            grid-template-rows: repeat(3, 100px);
            gap: 5px; /* 格子之間的間距 */
            background-color: #555; /* 棋盤格線的顏色 */
            border: 5px solid #555;
            border-radius: 10px;
        }

        /* 棋盤中的每一格 */
        .cell {
            width: 100px;
            height: 100px;
            background-color: #ffffff; /* 白色背景 */
            
            /* 使用 Flexbox 讓 X 和 O 在格子中置中 */
            display: flex;
            align-items: center;
            justify-content: center;
            
            font-size: 3.5rem; /* X 和 O 的字體大小 */
            font-weight: bold;
            cursor: pointer; /* 滑鼠移上去時顯示手型 */
            transition: background-color 0.2s ease; /* 簡易的滑鼠懸停動畫 */
        }

        /* 滑鼠移到格子上的樣式 */
        .cell:hover {
            background-color: #f7f7f7; /* 懸停時背景變暗一點 */
        }
        
        /* 重新開始按鈕 */
        #restart-btn {
            margin-top: 25px; /* 距離棋盤 25px */
            padding: 12px 25px; /* 內邊距 */
            font-size: 1.1rem; /* 字體大小 */
            font-weight: bold;
            color: white; /* 白色文字 */
            background-color: #007bff; /* 藍色背景 */
            border: none; /* 移除預設邊框 */
            border-radius: 8px; /* 圓角 */
            cursor: pointer; /* 手型游標 */
            transition: background-color 0.2s ease;
        }

        /* 滑鼠移到按鈕上的樣式 */
        #restart-btn:hover {
            background-color: #0056b3; /* 懸停時顏色變深 */
        }

        /* 針對 'X' 和 'O' 顯示不同顏色 */
        .cell.x {
            color: #007bff; /* X 是藍色 */
        }
        .cell.o {
            color: #dc3545; /* O 是紅色 */
        }

    </style>
    <!-- CSS (樣式表) 結束 -->
</head>
<body>

    <!-- HTML (網頁結構) 開始 -->
    <!-- 這是使用者在畫面上看到的元素 -->

    <h1>井字遊戲</h1>

    <!-- 顯示遊戲狀態：輪到誰、誰贏了、或平手 -->
    <div id="status">玩家 X 的回合</div>

    <!-- 遊戲棋盤 -->
    <div id="game-board">
        <!-- 
          我們使用 data-index 來標記每個格子的索引 (0 到 8)
          這在 JavaScript 中會非常有用 
        -->
        <div class="cell" data-index="0"></div>
        <div class="cell" data-index="1"></div>
        <div class="cell" data-index="2"></div>
        <div class="cell" data-index="3"></div>
        <div class="cell" data-index="4"></div>
        <div class="cell" data-index="5"></div>
        <div class="cell" data-index="6"></div>
        <div class="cell" data-index="7"></div>
        <div class="cell" data-index="8"></div>
    </div>

    <!-- 重新開始按鈕 -->
    <button id="restart-btn">重新開始</button>

    <!-- HTML (網頁結構) 結束 -->


    <!-- JavaScript (程式邏輯) 開始 -->
    <!-- 所有的互動和遊戲規則都在這裡 -->
    <script>
        // 1. 等待 HTML 頁面完全載入後再執行
        document.addEventListener('DOMContentLoaded', () => {

            // 2. 獲取需要操作的 DOM 元素
            const cells = document.querySelectorAll('.cell'); // 獲取所有的格子 (這會是一個 NodeList, 類似陣列)
            const statusDisplay = document.getElementById('status'); // 獲取狀態顯示區域
            const restartButton = document.getElementById('restart-btn'); // 獲取重新開始按鈕

            // 3. 設定遊戲狀態變數
            let gameActive = true; // 遊戲是否正在進行中
            let currentPlayer = 'X'; // 目前的玩家，預設從 X 開始
            
            // 用一個陣列來儲存 9 個格子的狀態，空字串表示空格
            let gameState = ["", "", "", "", "", "", "", "", ""];

            // 4. 定義勝利條件
            // 這是所有可能的勝利組合 (3 橫、3 豎、2 斜)
            // 數字對應到格子的 data-index
            const winningConditions = [
                [0, 1, 2], // 橫排 1
                [3, 4, 5], // 橫排 2
                [6, 7, 8], // 橫排 3
                [0, 3, 6], // 豎排 1
                [1, 4, 7], // 豎排 2
                [2, 5, 8], // 豎排 3
                [0, 4, 8], // 斜角 1
                [2, 4, 6]  // 斜角 2
            ];

            // 5. 顯示目前回合的函式 (方便重複使用)
            const updateStatus = () => {
                statusDisplay.innerHTML = `玩家 ${currentPlayer} 的回合`;
            };

            // 6. 初始化遊戲
            updateStatus(); // 頁面載入時，立即顯示「玩家 X 的回合」

            // 7. 處理格子點擊事件的函式
            function handleCellClick(event) {
                // event.target 就是被點擊的那個 <div class="cell"> 元素
                const clickedCell = event.target;

                // 獲取該格子的 data-index (記得轉成數字)
                const clickedCellIndex = parseInt(clickedCell.getAttribute('data-index'));

                // 檢查：如果該格子已經有值 (不是"")，或者遊戲已經結束 (gameActive 為 false)
                // 就直接 return，不做任何事
                if (gameState[clickedCellIndex] !== "" || !gameActive) {
                    return;
                }

                // 如果一切正常，就處理下棋
                handleCellPlayed(clickedCell, clickedCellIndex);
                
                // 檢查遊戲結果 (是否有人勝利或平手)
                handleResultValidation();
            }

            // 8. 處理下棋 (更新格子內容和狀態)
            function handleCellPlayed(clickedCell, clickedCellIndex) {
                // 更新我們的狀態陣列
                gameState[clickedCellIndex] = currentPlayer;
                
                // 更新畫面上的 HTML
                clickedCell.innerHTML = currentPlayer;
                
                // 替格子加上 'x' 或 'o' 的 class，讓 CSS 可以幫它上色
                clickedCell.classList.add(currentPlayer.toLowerCase()); // 'X' -> 'x', 'O' -> 'o'
            }

            // 9. 檢查遊戲結果
            function handleResultValidation() {
                let roundWon = false; // 暫時假設還沒有人贏

                // 遍歷所有的勝利條件
                for (let i = 0; i < winningConditions.length; i++) {
                    const winCondition = winningConditions[i]; // 例如 [0, 1, 2]

                    // 獲取這三個格子的目前狀態
                    let a = gameState[winCondition[0]];
                    let b = gameState[winCondition[1]];
                    let c = gameState[winCondition[2]];

                    // 如果這三個格子有任何一個是空的，那就不可能連線
                    if (a === '' || b === '' || c === '') {
                        continue; // 繼續檢查下一個勝利條件
                    }

                    // 如果這三個格子都不是空的，而且內容都一樣
                    if (a === b && b === c) {
                        roundWon = true; // 找到勝利者！
                        break; // 結束迴圈，不用再檢查了
                    }
                }

                // 如果 roundWon 變成 true，表示有人贏了
                if (roundWon) {
                    statusDisplay.innerHTML = `玩家 ${currentPlayer} 勝利了！`;
                    gameActive = false; // 遊戲結束
                    return; // 結束函式
                }

                // 如果沒人贏，檢查是否平手 (所有格子都下滿了)
                // .includes("") 檢查陣列中是否還有空字串
                let roundDraw = !gameState.includes("");
                if (roundDraw) {
                    statusDisplay.innerHTML = `平手！`;
                    gameActive = false; // 遊戲結束
                    return;
                }

                // 如果沒人贏，也沒平手，就表示遊戲繼續
                // 換下一個玩家
                handlePlayerChange();
            }

            // 10. 切換玩家
            function handlePlayerChange() {
                // 簡單的三元運算子
                // 如果 currentPlayer 是 'X'，就換成 'O'，否則就換成 'X'
                currentPlayer = currentPlayer === "X" ? "O" : "X";
                
                // 更新狀態顯示
                updateStatus();
            }

            // 11. 重新開始遊戲
            function handleRestartGame() {
                // 將所有狀態恢復到初始值
                gameActive = true;
                currentPlayer = "X";
                gameState = ["", "", "", "", "", "", "", "", ""];
                
                // 恢復狀態顯示
                updateStatus();
                
                // 清空所有格子的內容和樣式
                cells.forEach(cell => {
                    cell.innerHTML = "";
                    cell.classList.remove('x', 'o'); // 移除 x 和 o 的 class
                });
            }

            // 12. 綁定事件監聽器
            // 為 9 個格子都綁上點擊事件
            cells.forEach(cell => cell.addEventListener('click', handleCellClick));
            
            // 為重新開始按鈕綁上點擊事件
            restartButton.addEventListener('click', handleRestartGame);
        });
    </script>
    <!-- JavaScript (程式邏輯) 結束 -->

    <div style="margin-top: 20px; text-align: center; font-size: 14px; color: #666;">
        提示：使用 `fn + F12` 或 `Command + Option + U` 可觀看原始碼
    </div>
</body>
</html>